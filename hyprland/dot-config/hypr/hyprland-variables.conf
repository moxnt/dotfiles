# __     __         _       _     _           
# \ \   / /_ _ _ __(_) __ _| |__ | | ___  ___ 
#  \ \ / / _` | '__| |/ _` | '_ \| |/ _ \/ __|
#   \ V / (_| | |  | | (_| | |_) | |  __/\__ \
#    \_/ \__,_|_|  |_|\__,_|_.__/|_|\___||___/
#
# A file containing all the options listed in https://wiki.hypr.land/Configuring/Variables
# general
# general:snap
# decoration
# decoration:blur
# decoration:shadow
# animations
# input
# input:touchpad
# input:toucdevice
# input:virtualkeyboard
# input:tablet
# gestures
# group
# group:groupbar
# misc
# binds
# xwayland
# opengl
# render
# cursor
# ecosystem
# quirks
# debug

# category - general
general {
# size of the border around windows int
  border_size = 4

#gaps between windows, also supports css style gaps (top, right, bottom, left -> 5,10,15,20) int
    gaps_in = 5

# gaps between windows and monitor edges, also supports css style gaps (top, right, bottom, left -> 5,10,15,20) int
    gaps_out = 2,6,6,6

# gaps between windows and monitor edges for floating windows, also supports css style gaps (top, right, bottom, left -> 5 10 15 20). -1 means default int
    float_gaps = 0

# gaps between workspaces. Stacks with gaps_out. int
    gaps_workspaces = 0

# border color for inactive windows gradient
    col.inactive_border = 0xff313131

# border color for the active window gradient
    col.active_border = 0xffa9acee

# inactive border color for window that cannot be added to a group (see denywindowfromgroup dispatcher) gradient
    col.nogroup_border = 0xff20becd

# active border color for window that cannot be added to a group gradient
    col.nogroup_border_active = 0xff21becf

# which layout to use. [dwindle/master] str
    layout = dwindle

# if true, will not fall back to the next available window when moving focus in a direction where no window was found bool
    no_focus_fallback = false

# enables resizing windows by clicking and dragging on borders and gaps bool
    resize_on_border = true

# extends the area around the border where you can click and drag on, only used when general:resize_on_border is on. int
    extend_border_grab_area = 15

# show a cursor icon when hovering over borders, only used when general:resize_on_border is on. bool
    hover_icon_on_border = true

# master switch for allowing tearing to occur. See the Tearing page. bool
    allow_tearing = true

# force floating windows to use a specific corner when being resized (1-4 going clockwise from top left, 0 to disable) int
    resize_corner = 0

# whether parent windows of modals will be interactive bool
    modal_parent_blocking = true

# overrides the system locale (e.g. en_US, es) str
    locale =

# category - general:snap
    snap {
# enable snapping for floating windows bool
      enabled = true

# minimum gap in pixels between windows before snapping int
        window_gap = 8

# minimum gap in pixels between window and monitor edges before snapping int
        monitor_gap = 8

# if true, windows snap such that only one border’s worth of space is between them bool
        border_overlap = false

# if true, snapping will respect gaps between windows(set in general:gaps_in) bool
        respect_gaps = true
    }
}

# category - decoration
decoration {
# rounded corners’ radius (in layout px) -> int
  rounding = 8

# adjusts the curve used for rounding corners, larger is smoother, 2.0 is a circle, 4.0 is a squircle, 1.0 is a triangular corner. [1.0 - 10.0] -> float
    rounding_power = 2.0

# opacity of active windows. [0.0 - 1.0] -> float
    active_opacity = 1.0

# opacity of inactive windows. [0.0 - 1.0] -> float
    inactive_opacity = 1.0

# opacity of fullscreen windows. [0.0 - 1.0] -> float
    fullscreen_opacity = 1.0

# enables dimming of parents of modal windows -> bool
    dim_modal = true

# enables dimming of inactive windows -> bool
    dim_inactive = false

# how much inactive windows should be dimmed [0.0 - 1.0] -> float
    dim_strength = 0.5

# how much to dim the rest of the screen by when a special workspace is open. [0.0 - 1.0] -> float
    dim_special = 0.2

# how much the dim_around window rule should dim by. [0.0 - 1.0] -> float
    dim_around = 0.4

# a path to a custom shader to be applied at the end of rendering. See examples/screenShader.frag for an example. -> str

# screen_shader = Empty by default

# whether the window border should be a part of the window -> bool
    border_part_of_window = true

# category - decoration:blur
    blur {
# enable kawase window background blur -> bool
      enabled = false

# blur size (distance) -> int
        size = 8

# the amount of passes to perform -> int
        passes = 1

# make the blur layer ignore the opacity of the window -> bool
        ignore_opacity = true

# whether to enable further optimizations to the blur. Recommended to leave on, as it will massively improve performance. -> bool
        new_optimizations = true

# if enabled, floating windows will ignore tiled windows in their blur. Only available if new_optimizations is true. Will reduce overhead on floating blur significantly. -> bool
        xray = false

# how much noise to apply. [0.0 - 1.0] -> float
        noise = 0.0117

# contrast modulation for blur. [0.0 - 2.0] -> float
        contrast = 0.8916

# brightness modulation for blur. [0.0 - 2.0] -> float
        brightness = 0.8172

# Increase saturation of blurred colors. [0.0 - 1.0] -> float
        vibrancy = 0.1696

# How strong the effect of vibrancy is on dark areas . [0.0 - 1.0] -> float
        vibrancy_darkness = 0.0

# whether to blur behind the special workspace (note: expensive) -> bool
        special = false

# whether to blur popups (e.g. right-click menus) -> bool
        popups = false

# works like ignore_alpha in layer rules. If pixel opacity is below set value, will not blur. [0.0 - 1.0] -> float
        popups_ignorealpha = 0.2

# whether to blur input methods (e.g. fcitx5) -> bool
        input_methods = false

# works like ignore_alpha in layer rules. If pixel opacity is below set value, will not blur. [0.0 - 1.0] -> float
        input_methods_ignorealpha = 0.2
    }

# category - decoration:shadow
  shadow {
# enable drop shadows on windows -> bool
    enabled = true

# Shadow range (“size”) in layout px -> int
      range = 16

# in what power to render the falloff (more power, the faster the falloff) [1 - 4] -> int
      render_power = 4

# if enabled, will make the shadows sharp, akin to an infinite render power -> bool
      sharp = false

# if true, the shadow will not be rendered behind the window itself, only around it. -> bool
      ignore_window = true

# shadow’s color. Alpha dictates shadow’s opacity. -> color
      color = 0xee797aca

# inactive shadow color. (if not set, will fall back to color) -> color
      color_inactive = 0x00000000

# shadow’s rendering offset. -> vec2
      offset = 0, 0

# shadow’s scale. [0.0 - 1.0] -> float
      scale = 1.0
  }
}

# category - animations
animations {
# enable animations -> bool
  enabled = true

# enable workspace wraparound, causing directional workspace animations to animate as if the first and last workspaces were adjacent -> bool
    workspace_wraparound = true
}

# category - input
input {
# Appropriate XKB keymap parameter. See the note below. -> str
  kb_model =

# Appropriate XKB keymap parameter -> str
    kb_layout = us

# Appropriate XKB keymap parameter -> str
    kb_variant = colemak_dh

# Appropriate XKB keymap parameter -> str
    kb_options =

# Appropriate XKB keymap parameter -> str
    kb_rules =

# If you prefer, you can use a path to your custom .xkb file. -> str
    kb_file =

# Engage numlock by default. -> bool
    numlock_by_default = false

# Determines how keybinds act when multiple layouts are used. If false, keybinds will always act as if the first specified layout is active. If true, keybinds specified by symbols are activated when you type the respective symbol with the current layout. -> bool
    resolve_binds_by_sym = false

# The repeat rate for held-down keys, in repeats per second. -> int
    repeat_rate = 25

# Delay before a held-down key is repeated, in milliseconds. -> int
    repeat_delay = 400

# Sets the mouse input sensitivity. Value is clamped to the range -1.0 to 1.0. libinput#pointer-acceleration -> float
    sensitivity = 0.0

# Sets the cursor acceleration profile. Can be one of adaptive, flat. Can also be custom, see below. Leave empty to use libinput’s default mode for your input device. libinput#pointer-acceleration [adaptive/flat/custom] -> str
    accel_profile =

# Force no cursor acceleration. This bypasses most of your pointer settings to get as raw of a signal as possible. Enabling this is not recommended due to potential cursor desynchronization. -> bool
    force_no_accel = false

# Sets the rotation of a device in degrees clockwise off the logical neutral position. Value is clamped to the range 0 to 359. -> int
    rotation = 0

# Switches RMB and LMB -> bool
    left_handed = false

# Sets the scroll acceleration profile, when accel_profile is set to custom. Has to be in the form <step> <points>. Leave empty to have a flat scroll curve. -> str
    scroll_points =

# Sets the scroll method. Can be one of 2fg (2 fingers), edge, on_button_down, no_scroll. libinput#scrolling [2fg/edge/on_button_down/no_scroll] -> str
    scroll_method =

# Sets the scroll button. Has to be an int, cannot be a string. Check wev if you have any doubts regarding the ID. 0 means default. -> int
    scroll_button = 0

# If the scroll button lock is enabled, the button does not need to be held down. Pressing and releasing the button toggles the button lock, which logically holds the button down or releases it. While the button is logically held down, motion events are converted to scroll events. -> bool
    scroll_button_lock = false

# Multiplier added to scroll movement for external mice. Note that there is a separate setting for touchpad scroll_factor. -> float
    scroll_factor = 1.2

# Inverts scrolling direction. When enabled, scrolling moves content directly, rather than manipulating a scrollbar. -> bool
    natural_scroll = false

# Specify if and how cursor movement should affect window focus. See the note below. [0/1/2/3] -> int
    follow_mouse = 1

# The smallest distance in logical pixels the mouse needs to travel for the window under it to get focused. Works only with follow_mouse = 1. -> float
    follow_mouse_threshold = 0.0

# Controls the window focus behavior when a window is closed. When set to 0, focus will shift to the next window candidate. When set to 1, focus will shift to the window under the cursor. [0/1] -> int
    focus_on_close = 0

# If disabled, mouse focus won’t switch to the hovered window unless the mouse crosses a window boundary when follow_mouse=1. -> bool
    mouse_refocus = true

# If enabled (1 or 2), focus will change to the window under the cursor when changing from tiled-to-floating and vice versa. If 2, focus will also follow mouse on float-to-float switches. -> int
    float_switch_override_focus = 1

# if enabled, having only floating windows in the special workspace will not block focusing windows in the regular workspace. -> bool
    special_fallthrough = false

# Handles axis events around (gaps/border for tiled, dragarea/border for floated) a focused window. 0 ignores axis events 1 sends out-of-bound coordinates 2 fakes pointer coordinates to the closest point inside the window 3 warps the cursor to the closest point inside the window -> int
    off_window_axis_events = 1

# Emulates discrete scrolling from high resolution scrolling events. 0 disables it, 1 enables handling of non-standard events only, and 2 force enables all scroll wheel events to be handled -> int
    emulate_discrete_scroll = 1



# XKB Settings

# You can find a list of models, layouts, variants and options in /usr/share/X11/xkb/rules/evdev.lst. Alternatively, you can use the localectl command to discover what is available on your system.

# 

# Follow Mouse Cursor
# 
#     0 - Cursor movement will not change focus.
#     1 - Cursor movement will always change focus to the window under the cursor.
#     2 - Cursor focus will be detached from keyboard focus. Clicking on a window will move keyboard focus to that window.
#     3 - Cursor focus will be completely separate from keyboard focus. Clicking on a window will not change keyboard focus.

# category - input:touchpad
    touchpad {
# Disable the touchpad while typing. -> bool
      disable_while_typing = true

# Inverts scrolling direction. When enabled, scrolling moves content directly, rather than manipulating a scrollbar. -> bool
        natural_scroll = false

# Multiplier applied to the amount of scroll movement. -> float
        scroll_factor = 1.0

# Sending LMB and RMB simultaneously will be interpreted as a middle click. This disables any touchpad area that would normally send a middle click based on location. libinput#middle-button-emulation -> bool
        middle_button_emulation = false

# Sets the tap button mapping for touchpad button emulation. Can be one of lrm (default) or lmr (Left, Middle, Right Buttons). [lrm/lmr] -> str
        tap_button_map =

# Button presses with 1, 2, or 3 fingers will be mapped to LMB, RMB, and MMB respectively. This disables interpretation of clicks based on location on the touchpad. libinput#clickfinger-behavior -> bool
        clickfinger_behavior = false

# Tapping on the touchpad with 1, 2, or 3 fingers will send LMB, RMB, and MMB respectively. -> bool
        tap-to-click = true

# When enabled, lifting the finger off while dragging will not drop the dragged item. 0 -> disabled, 1 -> enabled with timeout, 2 -> enabled sticky. libinput#tap-and-drag -> int
        drag_lock = 0

# Sets the tap and drag mode for the touchpad -> bool
        tap-and-drag = true

# inverts the horizontal movement of the touchpad -> bool
        flip_x = false

# inverts the vertical movement of the touchpad -> bool
        flip_y = false

# enables three finger drag, 0 -> disabled, 1 -> 3 fingers, 2 -> 4 fingers libinput#drag-3fg -> int
        drag_3fg = 0
    }

# category - input:touchdevice
  touchdevice {
# Transform the input from touchdevices. The possible transformations are the same as those of the monitors. -1 means it’s unset. -> int
    transform = -1

# The monitor to bind touch devices. The default is auto-detection. To stop auto-detection, use an empty string or the “[[Empty]]” value. -> string
      output =

# Whether input is enabled for touch devices. -> bool
      enabled = true
  }

# category - input:virtualkeyboard
  virtualkeyboard {
# Unify key down states and modifier states with other keyboards. 0 -> no, 1 -> yes, 2 -> yes unless IME client -> int
    share_states = 2

# Release all pressed keys by virtual keyboard on close. -> bool
      release_pressed_on_close = false
  }

# category - input:tablet
  tablet {
# transform the input from tablets. The possible transformations are the same as those of the monitors. -1 means it’s unset. -> int
    transform = -1

# the monitor to bind tablets. Can be current or a monitor name. Leave empty to map across all monitors. -> string
      output =

# position of the mapped region in monitor layout relative to the top left corner of the bound monitor or all monitors. -> vec2
      region_position = 0, 0

# whether to treat the region_position as an absolute position in monitor layout. Only applies when output is empty. -> bool
      absolute_region_position = false

# size of the mapped region. When this variable is set, tablet input will be mapped to the region. [0, 0] or invalid size means unset. -> vec2
      region_size = 0, 0

# whether the input should be relative -> bool
      relative_input = false

# if enabled, the tablet will be rotated 180 degrees -> bool
      left_handed = false

# size of tablet’s active area in mm -> vec2
      active_area_size = 0, 0

# position of the active area in mm -> vec2
      active_area_position = 0, 0
  }
}

# category - gestures
gestures {
# in px, the distance of the touchpad gesture -> int
  workspace_swipe_distance = 300

# enable workspace swiping from the edge of a touchscreen -> bool
    workspace_swipe_touch = false

# invert the direction (touchpad only) -> bool
    workspace_swipe_invert = true

# invert the direction (touchscreen only) -> bool
    workspace_swipe_touch_invert = false

# minimum speed in px per timepoint to force the change ignoring cancel_ratio. Setting to 0 will disable this mechanic. -> int
    workspace_swipe_min_speed_to_force = 30

# how much the swipe has to proceed in order to commence it. (0.7 -> if > 0.7 * distance, switch, if less, revert) [0.0 - 1.0] -> float
    workspace_swipe_cancel_ratio = 0.5

# whether a swipe right on the last workspace should create a new one. -> bool
    workspace_swipe_create_new = true

# if enabled, switching direction will be locked when you swipe past the direction_lock_threshold (touchpad only). -> bool
    workspace_swipe_direction_lock = true

# in px, the distance to swipe before direction lock activates (touchpad only). -> int
    workspace_swipe_direction_lock_threshold = 10

# if enabled, swiping will not clamp at the neighboring workspaces but continue to the further ones. -> bool
    workspace_swipe_forever = false

# if enabled, swiping will use the r prefix instead of the m prefix for finding workspaces. -> bool
    workspace_swipe_use_r = false

# the timeout for a window to close when using a 1:1 gesture, in ms -> int
    close_max_timeout = 1000
}

# category - group
group {
# whether new windows will be automatically grouped into the focused unlocked group. Note: if you want to disable auto_group only for specific windows, use the “group barred” window rule instead. -> bool
  auto_group = true

# whether new windows in a group spawn after current or at group tail -> bool
    insert_after_current = true

# whether Hyprland should focus on the window that has just been moved out of the group -> bool
    focus_removed_window = true

# whether dragging a window into a unlocked group will merge them. Options: 0 (disabled), 1 (enabled), 2 (only when dragging into the groupbar) -> int
    drag_into_group = 1

# whether window groups can be dragged into other groups -> bool
    merge_groups_on_drag = true

# whether one group will be merged with another when dragged into its groupbar -> bool
    merge_groups_on_groupbar = true

# whether dragging a floating window into a tiled window groupbar will merge them -> bool
    merge_floated_into_tiled_on_groupbar = false

# whether using movetoworkspace[silent] will merge the window into the workspace’s solitary unlocked group -> bool
    group_on_movetoworkspace = false

# active group border color -> gradient
    col.border_active = 0xffa9acee

# inactive (out of focus) group border color -> gradient
    col.border_inactive = 0xff313131

# active locked group border color -> gradient
    col.border_locked_active = 0x000000ff

# inactive locked group border color -> gradient
    col.border_locked_inactive = 0xff000000

# category - group:groupbar
    groupbar {
# enables groupbars -> bool
      enabled = true

# font used to display groupbar titles, use misc:font_family if not specified -> string
        font_family = ZenlessFont

# font size of groupbar title -> int
        font_size = 22

# font weight of active groupbar title -> font_weight
        font_weight_active = normal

# font weight of inactive groupbar title -> font_weight
        font_weight_inactive = normal

# enables gradients -> bool
        gradients = true

# height of the groupbar -> int
        height = 26

# height of gap between groupbar indicator and title -> int
        indicator_gap = 2

# height of the groupbar indicator -> int
        indicator_height = 0

# render the groupbar as a vertical stack -> bool
        stacked = false

# sets the decoration priority for groupbars -> int
        priority = 3

# whether to render titles in the group bar decoration -> bool
        render_titles = true

# adjust vertical position for titles -> int
        text_offset = 0

# set horizontal padding for titles -> int
        # text_padding = 0 !!! Does not exist

# whether scrolling in the groupbar changes group active window -> bool
        scrolling = true

# how much to round the indicator -> int
        rounding = 0

# adjusts the curve used for rounding groupbar corners, larger is smoother, 2.0 is a circle, 4.0 is a squircle, 1.0 is a triangular corner. [1.0 - 10.0] -> float
        rounding_power = 3.0

# how much to round the gradients -> int
        gradient_rounding = 6

# adjusts the curve used for rounding gradient corners, larger is smoother, 2.0 is a circle, 4.0 is a squircle, 1.0 is a triangular corner. [1.0 - 10.0] -> float
        gradient_rounding_power = 4.0

# round only the indicator edges of the entire groupbar -> bool
        round_only_edges = true

# round only the gradient edges of the entire groupbar -> bool
        gradient_round_only_edges = false
    
# color for window titles in the groupbar -> color
        text_color = 0xffa9acee

# color for inactive windows’ titles in the groupbar (if unset, defaults to text_color) -> color
        text_color_inactive = 0xffa1a1a1

# color for the active window’s title in a locked group (if unset, defaults to text_color) -> color
        # text_color_locked_active = unset

# color for inactive windows’ titles in locked groups (if unset, defaults to text_color_inactive) -> color
        # text_color_locked_inactive = unset

# active group bar background color -> gradient
        col.active = 0xff252525

# inactive (out of focus) group bar background color -> gradient
        col.inactive = 0xff1e1e1e

# active locked group bar background color -> gradient
        col.locked_active = 0x66ff5500

# inactive locked group bar background color -> gradient
        col.locked_inactive = 0x66775500

# gap size between gradients -> int
        gaps_in = 4

# gap size between gradients and window -> int
        gaps_out = 2

# add or remove upper gap -> bool
        keep_upper_gap = false

# applies blur to the groupbar indicators and gradients -> bool
        blur = false
    }
}

# category - misc
misc {
# disables the random Hyprland logo / anime girl background. :( -> bool
    disable_hyprland_logo = true

# disables the Hyprland splash rendering. (requires a monitor reload to take effect) -> bool
    disable_splash_rendering = false

# disables notification popup when a monitor fails to set a suitable scale -> bool
    disable_scale_notification = false

# Changes the color of the splash text (requires a monitor reload to take effect). -> color
    col.splash = 0xffffffff

# Set the global default font to render the text including debug fps/notification, config error messages and etc., selected from system fonts. -> string
    font_family = Roboto

# Changes the font used to render the splash text, selected from system fonts (requires a monitor reload to take effect). -> string
    splash_font_family = ZenlessFont

# Enforce any of the 3 default wallpapers. Setting this to 0 or 1 disables the anime background. -1 means “random”. [-1/0/1/2] -> int
    force_default_wallpaper = -1

# controls the VFR status of Hyprland. Heavily recommended to leave enabled to conserve resources. -> bool
    vfr = true

# controls the VRR (Adaptive Sync) of your monitors. 0 - off, 1 - on, 2 - fullscreen only, 3 - fullscreen with video or game content type [0/1/2/3] -> int
    vrr = 3

# If DPMS is set to off, wake up the monitors if the mouse moves. -> bool
    mouse_move_enables_dpms = false

# If DPMS is set to off, wake up the monitors if a key is pressed. -> bool
    key_press_enables_dpms = false

# Name virtual keyboards after the processes that create them. E.g. /usr/bin/fcitx5 will have hl-virtual-keyboard-fcitx5. -> bool
    name_vk_after_proc = true

# Will make mouse focus follow the mouse when drag and dropping. Recommended to leave it enabled, especially for people using focus follows mouse at 0. -> bool
    always_follow_on_dnd = true

# If true, will make keyboard-interactive layers keep their focus on mouse move (e.g. wofi, bemenu) -> bool
    layers_hog_keyboard_focus = true

# If true, will animate manual window resizes/moves -> bool
    animate_manual_resizes = false

# If true, will animate windows being dragged by mouse, note that this can cause weird behavior on some curves -> bool
    animate_mouse_windowdragging = true

# If true, the config will not reload automatically on save, and instead needs to be reloaded with hyprctl reload. Might save on battery. -> bool
    disable_autoreload = false

# Enable window swallowing -> bool
    enable_swallow = true

# The class regex to be used for windows that should be swallowed (usually, a terminal). To know more about the list of regex which can be used use this cheatsheet. -> str
    swallow_regex = ^(kitty)$

# The title regex to be used for windows that should not be swallowed by the windows specified in swallow_regex (e.g. wev). The regex is matched against the parent (e.g. Kitty) window’s title on the assumption that it changes to whatever process it’s running. -> str
    # swallow_exception_regex = 

# Whether Hyprland should focus an app that requests to be focused (an activate request) -> bool
    focus_on_activate = false

# Whether mouse moving into a different monitor should focus it -> bool
    mouse_move_focuses_monitor = true

# if true, will allow you to restart a lockscreen app in case it crashes -> bool
    allow_session_lock_restore = false

# if true, keep rendering workspaces below your lockscreen -> bool
    session_lock_xray = false

# change the background color. (requires enabled disable_hyprland_logo) -> color
    background_color = 0x111111

# close the special workspace if the last window is removed -> bool
    close_special_on_empty = true

# if there is a fullscreen or maximized window, decide whether a tiled window requested to focus should replace it, stay behind or disable the fullscreen/maximized state. 0 - ignore focus request (keep focus on fullscreen window), 1 - takes over, 2 - unfullscreen/unmaximize [0/1/2] -> int
    on_focus_under_fullscreen = 2

# if true, closing a fullscreen window makes the next focused window fullscreen -> bool
    exit_window_retains_fullscreen = false

# if enabled, windows will open on the workspace they were invoked on. 0 - disabled, 1 - single-shot, 2 - persistent (all children too) -> int
    initial_workspace_tracking = 1

# whether to enable middle-click-paste (aka primary selection) -> bool
    middle_click_paste = true

# the maximum limit for render_unfocused windows’ fps in the background (see also Window-Rules - render_unfocused) -> int
    render_unfocused_fps = 15

# disable the warning if XDG environment is externally managed -> bool
    disable_xdg_env_checks = false

# disable the warning if hyprland-qtutils is not installed -> bool
    # disable_hyprland_qtutils_check = false !!! Does not exist

# delay after which the “lockdead” screen will appear in case a lockscreen app fails to cover all the outputs (5 seconds max) -> int
    lockdead_screen_delay = 1000

# whether to enable the ANR (app not responding) dialog when your apps hang -> bool
    enable_anr_dialog = true

# number of missed pings before showing the ANR dialog -> int
    anr_missed_pings = 5

# whether to apply min_size and max_size rules to tiled windows -> bool
    size_limits_tiled = false

# whether to disable the warning about not using start-hyprland -> bool
    disable_watchdog_warning = false
}

# category - binds
binds {
# if disabled, will not pass the mouse events to apps / dragging windows around if a keybind has been triggered. -> bool
  pass_mouse_when_bound = false

# in ms, how many ms to wait after a scroll event to allow passing another one for the binds. -> int
    scroll_event_delay = 300

# If enabled, an attempt to switch to the currently focused workspace will instead switch to the previous workspace. Akin to i3’s auto_back_and_forth. -> bool
    workspace_back_and_forth = true

# If enabled, changing the active workspace (including to itself) will hide the special workspace on the monitor where the newly active workspace resides. -> bool
    hide_special_on_workspace_change = true

# If enabled, workspaces don’t forget their previous workspace, so cycles can be created by switching to the first workspace in a sequence, then endlessly going to the previous workspace. -> bool
    allow_workspace_cycles = true

# Whether switching workspaces should center the cursor on the workspace (0) or on the last active window for that workspace (1) -> int
    workspace_center_on = 0

# sets the preferred focus finding method when using focuswindow/movewindow/etc with a direction. 0 - history (recent have priority), 1 - length (longer shared edges have priority) -> int
    focus_preferred_method = 0

# If enabled, dispatchers like moveintogroup, moveoutofgroup and movewindoworgroup will ignore lock per group. -> bool
    ignore_group_lock = false

# If enabled, when on a fullscreen window, movefocus will cycle fullscreen, if not, it will move the focus in a direction. -> bool
    movefocus_cycles_fullscreen = false

# If enabled, when in a grouped window, movefocus will cycle windows in the groups first, then at each ends of tabs, it’ll move on to other windows/groups -> bool
    movefocus_cycles_groupfirst = false

# If enabled, apps that request keybinds to be disabled (e.g. VMs) will not be able to do so. -> bool
    disable_keybind_grabbing = false

# If enabled, moving a window or focus over the edge of a monitor with a direction will move it to the next monitor in that direction. -> bool
    window_direction_monitor_fallback = true

# If enabled, Allow fullscreen to pinned windows, and restore their pinned status afterwards -> bool
    allow_pin_fullscreen = false

# Movement threshold in pixels for window dragging and c/g bind flags. 0 to disable and grab on mousedown. -> int
    drag_threshold = 0
}

# category - xwayland
xwayland {
# allow running applications using X11 -> bool
  enabled = true

# uses the nearest neighbor filtering for xwayland apps, making them pixelated rather than blurry -> bool
    use_nearest_neighbor = true

# forces a scale of 1 on xwayland windows on scaled displays. -> bool
    force_zero_scaling = false

# Create the abstract Unix domain socket for XWayland connections. (XWayland restart is required for changes to take effect; Linux only) -> bool
    create_abstract_socket = false
}

# category - opengl
opengl {
# reduces flickering on nvidia at the cost of possible frame drops on lower-end GPUs. On non-nvidia, this is ignored. -> bool
  nvidia_anti_flicker = true
}

# category - render
render {
# Enables direct scanout. Direct scanout attempts to reduce lag when there is only one fullscreen application on a screen (e.g. game). It is also recommended to set this to false if the fullscreen application shows graphical glitches. 0 - off, 1 - on, 2 - auto (on with content type ‘game’) -> int
  direct_scanout = 2

# Whether to expand undersized textures along the edge, or rather stretch the entire texture. -> bool
    expand_undersized_textures = true

# Disables back buffer and bottom layer rendering. -> bool
    xp_mode = false

# Whether to enable a fade animation for CTM changes (hyprsunset). 2 means “auto” which disables them on Nvidia. -> int
    ctm_animation = 2

# Passthrough color settings for fullscreen apps when possible. 0 - off, 1 - always, 2 - hdr only -> int
    cm_fs_passthrough = 2

# Whether the color management pipeline should be enabled or not (requires a restart of Hyprland to fully take effect) -> bool
    cm_enabled = true

# Report content type to allow monitor profile autoswitch (may result in a black screen during the switch) -> bool
    send_content_type = true

# Auto-switch to HDR in fullscreen when needed. 0 - off, 1 - switch to cm, hdr, 2 - switch to cm, hdredid -> int
    cm_auto_hdr = 1

# Automatically uses triple buffering when needed, improves FPS on underpowered devices. -> bool

# cm_auto_hdr requires --target-colorspace-hint-mode=source mpv option to work with mpv versions greater than v0.40.0
    new_render_scheduling = false

# Enable CM without shader. 0 - disable, 1 - whenever possible, 2 - DS and passthrough only, 3 - disable and ignore CM issues -> int
    non_shader_cm = 3

# Default transfer function for displaying SDR apps. 0 - Default (currently gamma22), 1 - Treat unspecified as Gamma 2.2, 2 - Treat unspecified and sRGB as Gamma 2.2, 3 - Treat unspecified as sRGB (previous default) -> int
    cm_sdr_eotf = 0
}

# category - cursor
cursor {
# don’t render cursors -> bool
  invisible = false

# sync xcursor theme with gsettings, it applies cursor-theme and cursor-size on theme load to gsettings making most CSD gtk based clients use same xcursor theme and size. -> bool
    sync_gsettings_theme = true

# disables hardware cursors. 0 - use hw cursors if possible, 1 - don’t use hw cursors, 2 - auto (disable when tearing) -> int
    no_hardware_cursors = 2

# disables scheduling new frames on cursor movement for fullscreen apps with VRR enabled to avoid framerate spikes (may require no_hardware_cursors = true) 0 - off, 1 - on, 2 - auto (on with content type ‘game’) -> int
    no_break_fs_vrr = 2

# minimum refresh rate for cursor movement when no_break_fs_vrr is active. Set to minimum supported refresh rate or higher -> int
    min_refresh_rate = 24

# the padding, in logical px, between screen edges and the cursor -> int
    hotspot_padding = 1

# in seconds, after how many seconds of cursor’s inactivity to hide it. Set to 0 for never. -> float
    inactive_timeout = 0

# if true, will not warp the cursor in many cases (focusing, keybinds, etc) -> bool
    no_warps = false

# When a window is refocused, the cursor returns to its last position relative to that window, rather than to the centre. -> bool
    persistent_warps = false

# Move the cursor to the last focused window after changing the workspace. Options: 0 (Disabled), 1 (Enabled), 2 (Force - ignores cursor:no_warps option) -> int
    warp_on_change_workspace = 0

# Move the cursor to the last focused window when toggling a special workspace. Options: 0 (Disabled), 1 (Enabled), 2 (Force - ignores cursor:no_warps option) -> int
    warp_on_toggle_special = 0

# the name of a default monitor for the cursor to be set to on startup (see hyprctl monitors for names) -> str
    default_monitor =

# the factor to zoom by around the cursor. Like a magnifying glass. Minimum 1.0 (meaning no zoom) -> float
    zoom_factor = 1.0

# whether the zoom should follow the cursor rigidly (cursor is always centered if it can be) or loosely -> bool
    zoom_rigid = false

# detach the camera from the mouse when zoomed in, only ever moving the camera to keep the mouse in view when it goes past the screen edges -> bool
    zoom_detached_camera = true

# whether to enable hyprcursor support -> bool
    enable_hyprcursor = true

# Hides the cursor when you press any key until the mouse is moved. -> bool
    hide_on_key_press = false

# Hides the cursor when the last input was a touch input until a mouse input is done. -> bool
    hide_on_touch = true

# Hides the cursor when the last input was a tablet input until a mouse input is done. -> bool
    hide_on_tablet = true

# Makes HW cursors use a CPU buffer. Required on Nvidia to have HW cursors. 0 - off, 1 - on, 2 - auto (nvidia only) -> int
    use_cpu_buffer = 2

# Warp the cursor back to where it was after using a non-mouse input to move it, and then returning back to mouse. -> bool
    warp_back_after_non_mouse_input = false

# disable antialiasing when zooming, which means things will be pixelated instead of blurry -> bool
    zoom_disable_aa = false
}

# category - ecosystem
ecosystem {
# disable the popup that shows up when you update hyprland to a new version. -> bool
  no_update_news = false

# disable the popup that shows up twice a year encouraging to donate. -> bool
    no_donation_nag = false

# whether to enable permission control. -> bool
    enforce_permissions = false
}

# category - quirks
quirks {
# Report HDR mode as preferred. 0 - off, 1 - always, 2 - gamescope only -> int
  prefer_hdr = 0
# Some clients expect monitor to be in HDR mode prior to the client start. This breaks auto HDR activation and can cause whitescreen and flickering. Use prefer_hdr to fix it,
}

# category - debug
debug {
# Warning: Only for developers.

# print the debug performance overlay. Disable VFR for accurate results. -> bool
  overlay = false

# (epilepsy warning!) flash areas updated with damage tracking -> bool
    damage_blink = false

# disable logging to a file -> bool
    disable_logs = true

# disables time logging -> bool
    disable_time = true

# redraw only the needed bits of the display. Do not change. (default: full - 2) monitor - 1, none - 0 -> int
    damage_tracking = 2

# enables logging to stdout -> bool
    enable_stdout_logs = false

# set to 1 and then back to 0 to crash Hyprland. -> int
    manual_crash = 0

# if true, do not display config file parsing errors. -> bool
    suppress_errors = false

# sets the timeout in seconds for watchdog to abort processing of a signal of the main thread. Set to 0 to disable. -> int
    # watchdog_timeout = 5 !!! Does not exist

# disables verification of the scale factors. Will result in pixel alignment and rounding errors. -> bool
    disable_scale_checks = false

# limits the number of displayed config file parsing errors. -> int
    error_limit = 8

# sets the position of the error bar. top - 0, bottom - 1 -> int
    error_position = 0

# enables colors in the stdout logs. -> bool
    colored_stdout_logs = true

# enables render pass debugging. -> bool
    pass = false

# claims support for all cm proto features (requires restart) -> bool
    full_cm_proto = false
}

# u1014 w/ <3

# There are more config options listed in other pages of the hyprland wiki,
# but these are all the options in the variables section as of January 24, 2026

# Additional notes:
# Options marked with !!! are present in the wiki, but threw a 'does not exist error'
# `option =` means `option = ""` so for colors and integers it may not be a valid option
